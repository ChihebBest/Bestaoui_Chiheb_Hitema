# -*- coding: utf-8 -*-
"""TD_DF.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1leiuqPPms4-4QnbCnntDOcVhwF_NtvLm
"""

#Calculer le prix minimum et maximum

with open("/content/drive/My Drive/mower_market_snapshot.csv", "r") as f:

  my_list = f.readlines()

price = []

for i in range (0,len(my_list)):
  price.append(my_list[i].split(";")[4])

print(min(price[1:len(price)]))
print(max(price[1:len(price)]))

#Stats du DataFrame

import pandas as pd
#import numpy as np

my_list = pd.read_csv('/content/drive/My Drive/mower_market_snapshot.csv', sep = ';')

df = pd.DataFrame(my_list)

df.describe()

#afficher les 5 premières lignes du fichier CSV 

df.head(100)

#sélectionner les lignes entre 100 et 150

df.loc[100:150]

#sélectionner les lignes entre 100 et 150 de la colonne price

df.loc[100:150, ('price')]

#Trier le DataFrame selon la valeur des prix

my_list.sort_values(by='price').head()

#Selectionner les lignes dont le prix > 500

df[ df['price'] > 500]

#Selectionner les lignes en choisissant des valeurs de price et ID

#df[ df['price'].isin([781.888696, 919.355522])]
df[ df['id'].isin([18961,19641])]

#Affiche les lignes qui contiennent une valeur NaN

df.dropna(how= 'any')

#Affiche les lignes qui contiennent une valeur NaN 2

df.dropna(axis = 1, how= 'any')

#Remplacer des lignes contenant NaN avec des 0

df['id'].fillna(0, inplace= True)  
df.head(150)

#Copier un DataFrame

df_copy = df.copy()

df_copy.head(20)

#Concaténer deux DataFrames

#df1 = pd.DataFrame(my_list[:20])
df1 = pd.DataFrame(my_list['id'])
#df2 = pd.DataFrame(my_list[21:40])
df2 = pd.DataFrame(my_list['price'])

pd.concat([df1, df2])

#Jointure avec intersection

#premier DF avec les colonnes id et price
df3 = my_list[['id','price']]

#deuxième DF avec uniquement la colonne price
df4 = pd.DataFrame(my_list['price'])

#Résultat de l'intersection
pd.concat([df3, df4], join = 'inner')

#Jointure avec union

#premier DF avec les colonnes id et price
df3 = my_list[['id','price','margin']]

#deuxième DF avec uniquement la colonne price
df4 = pd.DataFrame(my_list['price'])

#Résultat de l'union
pd.concat([df3, df4], join = 'outer')

#Jointure avec union LEFT ou RIGHT

#premier DF avec les colonnes id et price
df3 = my_list[['id','price','margin']]

#deuxième DF avec uniquement la colonne price
df4 = pd.DataFrame(my_list['price'])

#Résultat de la jointure
pd.merge(df3, df4, on= 'price', how='left')

#Groupements SUM
#Résultat: Grouper le dataframe avec les colonnes quality (low, high, medium) et lister la somme des élements ayant ces critères

df5 = my_list
df6 = my_list

df5.groupby(['quality']).sum()

#Groupements MEAN
#Résultat: Afficher les moyennes des valeurs des élements par rapport à un regroupement de quality (low, high, medium) et prix

df5 = my_list
df6 = my_list

df5.groupby(['quality', 'price']).mean()

#Créer une nouvelle colonne avec les bons chiffres des années

with open("/content/drive/My Drive/mower_market_snapshot.csv", "r") as f:

  my_list_2 = f.readlines()

#Liste à remplir avec des années de la colonne warranty
warranty = []

#Remplir la liste et extraire le premier caractère de chaque information qui représente l'année
for i in range (1,len(my_list_2)):
  warranty.append(my_list_2[i].split(";")[8][0])

ll =  pd.read_csv('/content/drive/My Drive/mower_market_snapshot.csv', sep = ';')
df7 = pd.DataFrame(ll)

#Insérer une colonne au DataFrame à la fin en gardant uniquement la valeur numérique de warranty
df7.insert(11, 'warranty_number', warranty, True)

df7

#Ajouter une colonne avec la valeur de product type par une variable quantitative

with open("/content/drive/My Drive/mower_market_snapshot.csv", "r") as f:

  my_list_2 = f.readlines()

#Liste à remplir avec des années de la colonne product_type
product_type = []

for i in range (1,len(my_list_2)):
  product_type.append(my_list_2[i].split(";")[6])

for i in range (0,len(product_type)):
  if (product_type[i] == 'auto-portee'):
    product_type[i] = 1
  else :
    if (product_type[i] == 'electrique'):
      product_type[i] = 2
    else:
      product_type[i] = 3

#product_type_2 = product_type[1:]

ll =  pd.read_csv('/content/drive/My Drive/mower_market_snapshot.csv', sep = ';')
df8 = pd.DataFrame(ll)

#Insérer une colonne au DataFrame à la fin en gardant uniquement la valeur numérique de warranty
df8.insert(11, 'product_type_number', product_type, True)
df8

#En plus simple: remplacer directement la valeur sur le champs correspendant au niveau de la colonne product_type

df10 = my_list
df10

for i in range (1, len(df10)):
  df10.loc[df10["product_type"] == "essence","product_type"] = 3
  df10.loc[df10["product_type"] == "auto-portee","product_type"] = 1
  df10.loc[df10["product_type"] == "electrique","product_type"] = 2

df10

#Retraitement de la colonne prod_cost
import numpy as np

my_list_12 = pd.read_csv('/content/drive/My Drive/mower_market_snapshot.csv', sep = ';')

df12 = pd.DataFrame(my_list_12)

#df11.groupby('prod_cost').sum()

#Convertir les élements en valeurs float
df12['prod_cost'] = pd.to_numeric(df12['prod_cost'],errors='coerce')

#Toute valeur négative ou nulle passe à NaN
df12.loc[df12['prod_cost'] <= 0 ] = np.nan

#Remplacer les NaN par la moyenne de la colonne
df12['prod_cost'] = df12['prod_cost'].fillna(df12['prod_cost'].mean())

#Vérification des valeurs remplacées
df12.groupby('prod_cost').sum()