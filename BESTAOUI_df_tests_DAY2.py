# -*- coding: utf-8 -*-
"""TD_DF.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1leiuqPPms4-4QnbCnntDOcVhwF_NtvLm
"""

#************************************DAY 1****************************************

#Calculer le prix minimum et maximum

with open("/content/drive/My Drive/mower_market_snapshot.csv", "r") as f:

  my_list = f.readlines()

price = []

for i in range (0,len(my_list)):
  price.append(my_list[i].split(";")[4])

print(min(price[1:len(price)]))
print(max(price[1:len(price)]))

#Stats du DataFrame

import pandas as pd
#import numpy as np

my_list = pd.read_csv('/content/drive/My Drive/mower_market_snapshot.csv', sep = ';')

df = pd.DataFrame(my_list)

df.describe()

#afficher les 5 premières lignes du fichier CSV 

df.head(100)

#sélectionner les lignes entre 100 et 150

df.loc[100:150]

#sélectionner les lignes entre 100 et 150 de la colonne price

df.loc[100:150, ('price')]

#Trier le DataFrame selon la valeur des prix

my_list.sort_values(by='price').head()

#Selectionner les lignes dont le prix > 500

df[ df['price'] > 500]

#Selectionner les lignes en choisissant des valeurs de price et ID

#df[ df['price'].isin([781.888696, 919.355522])]
df[ df['id'].isin([18961,19641])]

#Affiche les lignes qui contiennent une valeur NaN

df.dropna(how= 'any')

#Affiche les lignes qui contiennent une valeur NaN 2

df.dropna(axis = 1, how= 'any')

#Remplacer des lignes contenant NaN avec des 0

df['id'].fillna(0, inplace= True)  
df.head(150)

#Copier un DataFrame

df_copy = df.copy()

df_copy.head(20)

#***********************************DAY 2 ********************************************

#Concaténer deux DataFrames

#df1 = pd.DataFrame(my_list[:20])
df1 = pd.DataFrame(my_list['id'])
#df2 = pd.DataFrame(my_list[21:40])
df2 = pd.DataFrame(my_list['price'])

pd.concat([df1, df2])

#Jointure avec intersection

#premier DF avec les colonnes id et price
df3 = my_list[['id','price']]

#deuxième DF avec uniquement la colonne price
df4 = pd.DataFrame(my_list['price'])

#Résultat de l'intersection
pd.concat([df3, df4], join = 'inner')

#Jointure avec union

#premier DF avec les colonnes id et price
df3 = my_list[['id','price','margin']]

#deuxième DF avec uniquement la colonne price
df4 = pd.DataFrame(my_list['price'])

#Résultat de l'union
pd.concat([df3, df4], join = 'outer')

#Jointure avec union LEFT ou RIGHT

#premier DF avec les colonnes id et price
df3 = my_list[['id','price','margin']]

#deuxième DF avec uniquement la colonne price
df4 = pd.DataFrame(my_list['price'])

#Résultat de la jointure
pd.merge(df3, df4, on= 'price', how='left')

#Groupements SUM

df5 = my_list
df6 = my_list

df5.groupby(['quality', 'id']).sum()

#Groupements MEAN

df5 = my_list
df6 = my_list

df5.groupby(['quality', 'price', 'id']).mean()
